# ag-1931

```javascript
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = []

rl.on('line', function (line) {
    input.push(line);
}).on('close', function () {

    let answer = 0;
    let recent = [];
    let li = input.slice(1).map(el => el.split(" ").map(e => parseInt(e))).sort((a,b) => a[0]-b[0]).sort((a,b) => a[1] - b[1]);
    li.forEach((el, idx) => {
        if (idx == 0 || el[0] >= recent[1]){
            answer++;
            recent = el;
        }
    })
    console.log(answer)

    process.exit();

});
```

# 풀이방법
가장 회의가 일찍 끝나는 회의를 선택한 뒤, 겹치는 회의들을 제외한다.
이걸 위해 
1. 회의가 일찍 끝나는 순서대로 회의를 오름차순 정렬하고,
2. 정렬한 회의의 시작시간도 오름차순 정렬한다.

# 탐욕적 선택 속성
답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것.
이런 경우 탐욕법을 사용하는 것이 동적 계획법을 사용하는 것보다 시간 복잡도와 메모리 측면에서 나음

# sort
`input.slice(1).map(el => el.split(" ").map(e => parseInt(e))).sort((a,b) => a[0] - b[0]).sort((a,b) => a[1] - b[1]);`
`input.slice(1).map(el => el.split(" ").map(e => parseInt(e))).sort((a,b) => a[1] - b[1] || a[0] - b[0]);`
같은 형식
